<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ConditionalOnMissingBean注解的作用</title>
    <url>/2023/05/04/ConditionalOnMissingBean%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p><code>@ConditionalOnMissingBean</code>是修饰Bean的注解，它的作用是在容器中不存在某个 Bean 的时候才注册当前 Bean。</p>
<p>当一个类上添加了 <code>@ConditionalOnMissingBean</code> 注解后，在应用启动时，Spring 容器会检查当前上下文中是否已经存在该类型的 Bean。<br>如果不存在，就会将这个类声明的 Bean 加入到容器中；如果已经存在，则不会再注册该 Bean。</p>
<p><code>@ConditionalOnMissingBean</code> 注解可以用来确保某个 Bean 只被注册一次，并避免由于重复注册导致的问题。同时，也可以用来控制 Bean 实例的创建和注册顺序，从而更好地管理应用的依赖关系。</p>
<p><code>@ConditionalOnMissingBean</code>真正的意义在于其拓展性，当封装一个组件时，组件中有个默认的实现类，此时为这个默认实现类加上<code>@ConditionalOnMissingBean</code>注解。在外部使用时会用到自定义的Bean，此时出现多个相同类型的Bean，Spring会为我们选择不带<code>@ConditionalOnMissingBean</code>注解的Bean</p>
<p>也就是说<code>@ConditionalOnMissingBean</code>是当没有个性化Bean时，提供一个默认的Bean</p>
<p>PS：<br><a href="https://www.cnblogs.com/lori/p/13490005.html">springboot~@ConditionalOnMissingBean注解的作用 - 张占岭 - 博客园</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务传播Propagation.REQUIRES_NEW</title>
    <url>/2023/04/27/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%ADPropagation-REQUIRES-NEW/</url>
    <content><![CDATA[<p>新建事务，如果当前存在事务，把当前事务挂起。</p>
<p>在特殊需求的时候需要在一个方法内部<code>提前提交一部分事务</code>或者是让内部的一段代码处于<code>单独的一个事务管理</code>的时候需要用到REQUIRES_NEW</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@transaction</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;</span><br><span class="line">     dosomethingBefore...</span><br><span class="line">     methodA();</span><br><span class="line">     dosomgthingAfter...</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">     updateSomething();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>dosomethingBefore执行失败，testMethod直接回滚</p>
<p>updateSomething异常，回滚methodA，按照上述代码，全都回滚，如果被catch，就只回滚methodA</p>
<p>dosomgthingAfter异常，methodA事务已经提交，但testMethod中的修改全部回滚</p>
<p>PS：<br><a href="https://www.jianshu.com/p/3e9267b025b2">Propagation.REQUIRES_NEW</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>浅试Lambda</title>
    <url>/2023/04/27/Think-of-Lambda/</url>
    <content><![CDATA[<p>当我们在Java中使用Lambda表达式时，它们经常用于在一个函数中传递行为，即将Lambda表达式作为参数传递给方法，然后在方法中执行。<br>Java8实战这本书中的log方法传递Lambda参数执行的例子，是通过Lambda表达式实现在打印日志的同时打印出该日志执行的时间。<br>首先，我们创建一个Logger类，它的构造函数接受一个布尔值参数debug，用于确定是否打印日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> debug;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(<span class="type">boolean</span> debug)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.debug = debug;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">      System.out.println(LocalDateTime.now() + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们编写一个doSomething方法，该方法接受一个字符串和一个函数式接口作为参数。在方法中，我们打印日志并执行传入的函数式接口。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String message, Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>(<span class="literal">true</span>);</span><br><span class="line">    logger.log(<span class="string">&quot;Start &quot;</span> + message);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      runnable.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      logger.log(<span class="string">&quot;Error: &quot;</span> + e.getMessage());</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.log(<span class="string">&quot;Finish &quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doSomething方法先创建一个Logger对象来打印日志，然后在执行函数式接口之前打印“Start”日志，在执行后打印“Finish”日志。如果函数式接口抛出异常，则记录错误信息并将其继续传播。<br>最后，我们可以利用Lambda表达式调用doSomething方法，传递一个字符串和一个无参Lambda表达式，该Lambda表达式打印当前系统时间和一条消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Demo.doSomething(<span class="string">&quot;Print currentTime&quot;</span>, () -&gt; System.out.println(LocalDateTime.now()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将打印当前系统时间的Lambda表达式作为第二个参数传递给了doSomething方法。<br>当run方法在doSomething方法中执行时，打印当前时间的Lambda表达式就会被执行，并打印出当前时间。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式中的DCL</title>
    <url>/2023/04/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84DCL/</url>
    <content><![CDATA[<p>DCL 即 Double-Checked Locking</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance; </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">		<span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123; </span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">			<span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123; </span><br><span class="line">				uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> uniqueInstance; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>volatile 关键字修饰实例变量能够确保，当有一个线程访问 uniqueInstance 变量时，其他线程立即失效，强制从主内存中重新读取 uniqueInstance 的值。</p>
<p>使用DCL的原因：</p>
<ol>
<li>提高性能。使用双重检查锁可以在 getInstance() 第一次被调用时才实例化 Singleton 对象，即使多个线程同时调用 getInstance()，也只有第一次调用时才会进行同步锁定，其它线程会等待同步锁的释放。</li>
<li>在多线程环境下，使用 synchronized 关键字同步 getInstance() 方法可以保证线程安全，但是每次获取实例时都会进行同步锁的获取，带来性能损耗。</li>
</ol>
]]></content>
      <tags>
        <tag>Design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式实现PDF导出</title>
    <url>/2023/04/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0PDF%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<p>一个导出PDF的需求，使用Builder设计模式，用于简化传递参数和执行多次画线操作的流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageHeight;</span><br><span class="line">    <span class="keyword">private</span> List&lt;PdfLine&gt; lines = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PdfBuilder <span class="title function_">setPageNumber</span><span class="params">(<span class="type">int</span> pageNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pageNumber = pageNumber;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PdfBuilder <span class="title function_">setPageWidth</span><span class="params">(<span class="type">int</span> pageWidth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pageWidth = pageWidth;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PdfBuilder <span class="title function_">setPageHeight</span><span class="params">(<span class="type">int</span> pageHeight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pageHeight = pageHeight;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PdfBuilder <span class="title function_">addLine</span><span class="params">(<span class="type">int</span> startX, <span class="type">int</span> startY, <span class="type">int</span> endX, <span class="type">int</span> endY)</span> &#123;</span><br><span class="line">        lines.add(<span class="keyword">new</span> <span class="title class_">PdfLine</span>(startX, startY, endX, endY));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PdfDocument <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 PDF 文档对象</span></span><br><span class="line">        <span class="type">PdfDocument</span> <span class="variable">pdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PdfDocument</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 PDF 页面</span></span><br><span class="line">        <span class="type">PdfPage</span> <span class="variable">page</span> <span class="operator">=</span> pdf.addNewPage(pageWidth, pageHeight, pageNumber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在页面上画线</span></span><br><span class="line">        <span class="keyword">for</span> (PdfLine line : lines) &#123;</span><br><span class="line">            <span class="type">PdfCanvas</span> <span class="variable">canvas</span> <span class="operator">=</span> page.getCanvas();</span><br><span class="line">            canvas.beginText();</span><br><span class="line">            canvas.moveText(line.getStartX(), line.getStartY());</span><br><span class="line">            canvas.lineTo(line.getEndX(), line.getEndY());</span><br><span class="line">            canvas.stroke();</span><br><span class="line">            canvas.endText();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回 PDF 文档对象</span></span><br><span class="line">        <span class="keyword">return</span> pdf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先定义一个 <code>PdfBuilder</code> 类用于组合 PDF 页面。通过调用 <code>setPageNumber()</code>、<code>setPageWidth()</code>、<code>setPageHeight()</code>、<code>addLine()</code> 方法来设置页面属性和画线操作，最后通过调用 <code>build()</code> 方法将页面属性和画线操作组合为一个 PDF 文档对象并返回。</p>
<p>使用 Builder 设计模式可以让代码更加易读和易维护，同时避免了参数传递过程中出错的风险。</p>
]]></content>
      <categories>
        <category>Design pattern</category>
      </categories>
  </entry>
</search>
